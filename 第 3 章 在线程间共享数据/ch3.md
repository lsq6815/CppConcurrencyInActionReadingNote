# 第 3 章 在线程间共享数据

- [第 3 章 在线程间共享数据](#第-3-章-在线程间共享数据)
  - [内容提要](#内容提要)
  - [线程之间共享数据的问题](#线程之间共享数据的问题)
    - [竞争条件](#竞争条件)
    - [避免有问题的竞争条件](#避免有问题的竞争条件)
  - [用互斥元保护共享数据](#用互斥元保护共享数据)
    - [使用 C++ 中的互斥元](#使用-c-中的互斥元)
    - [为保护共享数据精心设计代码](#为保护共享数据精心设计代码)

使用线程实现并行的关键优点之一，就是在它们之间简单、直接地共享数据的潜力。但这也可以成为一个巨大的缺点，不正确使用共享数据是导致与并发相关的错误的原因之一。

本章涉及了在 C++ 线程间安全的共享数据，避免可能出现的潜在问题，同时使收益最大化。

## 内容提要

- 线程间共享数据的问题

- 用互斥元保护数据

- 用于保护共享数据的替代工具

## 线程之间共享数据的问题

从整体上看，所有线程之间共享数据的问题，都是修改数据导致的，如果所有的共享数据都是只读的，就没有问题，**因为一个线程所读取的数据不受另一个线程是否正在读取相同的数据的影响**。

> If all shared data is read-only, there's no problem, because the data read by one thread is unaffected by whether or not another thread is reading the same data.

然而，如果共享数据会同时被一个或多个线程修改，就有可能有很多麻烦。

一个被广泛用来帮助程序员推导代码的概念，就是**不变量（invariants）**——对于特定的数据结构总是为真的语句，例如「此变量包含了列表中项目的数量」。这些不变量在更新中经常被打破，尤其是在数据结构比较复杂或者更新需要修改**超过一个**值的时候。

考虑一个双向链表，它的每一个节点持有指向下一个节点和上一个节点的指针（`next`、`prev`）。其中一个**不变量**就是：你跟从一个节点（A）指向下一个节点（B）的「下一个」指针，则那个节点（B）的「前一个」指针一定指回前一个节点（A），即：

```cpp
A->next->prev == A
```

为了从表中删除一个节点，相邻的两个节点都必须被更新为指向彼此。一旦其中一个被更新了，直到另一个节点也被更新前不变量是被打破的，当更新完成后，再次持有不变量。

从这样的表中删除一个条目的步骤是：

1. 标记要删除的节点（`N`）。

2. 将 `N` 的前一节点到 `N` 的连接更新为指向 `N` 的后一节点。

    ```cpp
    N->prev->next = N->next;
    ```

3. 将 `N` 的后一节点到 `N` 的连接更新为指向 `N` 的前一节点。

    ```cpp
    N->next->prev = N->prev;
    ```

4. 删除节点 `N`。

可以预见，在步骤 2 和 3 之间，在一个方向上的连接没法反方向绕回，不变量被打破了。

修改线程之间共享数据的最简单潜在问题就是破坏不变量。假设一个删除节点的线程和一个读取线程。那么读取线程很有可能看到一个被部分删除的节点，不变量就被破坏了。又或者两个线程同时删除节点。无论结果如何，这是并发代码中最常见的错误诱因之一：**竞争条件（race condition）**。

### 竞争条件

在并发性中，竞争条件就是结果取决于两个及以上线程的操作的相对执行顺序的一切事物。尽管线程们在执行竞争操作时会有不同的执行顺序，造成的结果也可能随执行顺序的改变而不同，但大部分是良性的，可接受的。即：

- 改变线程们的执行顺序，不一定造成不同的结果；

- 不同的操作结果，可能都可以被接受；

例如：

> 有两个线程各自向一个 Queue 添加 Item，在保证 Queue 的不变量的情况下，谁先添加 Item 一般是不影响的。

在谈到并发时，术语 **竞争条件（race condition）** 通常指 **有问题的（problematic）** 竞争条件。毕竟良性的竞争条件是平凡的，无需深入研究的。C++ 标准还定义了术语 **数据竞争（data race）**，表示：因对单个对象的并发修改而产生的特定类型的竞争条件，数据竞争导致可怕的 **未定义行为（undefined behavior）**。

竞争条件通常发生在操作需要修改两个及以上数据块的地方，比如先前的双向链表的处理。竞争条件的问题在于很难发现出且复现困难，竞争条件的出现跟系统的负载和执行该操作的次数成正比。由于竞争条件是时间敏感的，竞争条件难以在调试工具中复现，因为调试工具会影响系统的时间。

如果你在编写多线程程序，竞争条件会轻易地成为你的灾难。编写并发软件的复杂性，大量来自于避免有问题的竞争条件。

### 避免有问题的竞争条件

有几种方法来处理有问题的竞争条件。

- 使用保护机制封装你的数据结构，确保只有执行修改的线程可以在不变量损坏的地方访问中间数据。从其他访问数据结构的线程的视角看，这种修改要么还没开始要么已经完成。C++ 标准库提供了这样的机制，本章主要叙述这种方法。

- 修改数据结构的设计及其不变量，使得对数据结构的修改是作为一系列不可分割的操作执行的，每个修改都保留不变量。这通常称之为**无锁编程（lock-free programming）**。在这种编程范式下，内存模型的细微差异和确认线程对数据的可访问性，会变得很复杂。内存模型在第 5 章介绍，而无锁编程在第 7 章进行讨论。

- 将对数据结构的更改作为一个 **事务（transaction）** 来处理，就如同数据库中的事务概念一样。所需的一系列修改和读取被保存在一个事务日志中，然后在单个步骤中进行提交。如果该提交因为数据结构已被另一个线程的修改而无法进行，该事务将重新启动。这称为 **软件事务内存（software transactional memory，STM）**，由于 C++ 没有对 STM 的直接支持，这本书不会涉及。这种思想之后会提及。

由 C++ 提供的保护共享数据的最基本机制就是 **互斥元（mutex）**。

## 用互斥元保护共享数据

**互斥元（mutex，mutex exclusion）** 实现了互斥的同步原语。在访问共享数据前，**锁定（lock）** 与该数据相关的互斥元，当对数据的访问结束后，**解锁（unlock）** 该互斥元。线程库会确保一旦一个线程已经锁定某个互斥元，其他尝试锁定相同互斥元的线程必须等待，直到之前锁定了互斥元的线程解锁该互斥元。这就确保所有线程看到的共享数据是保证不变量的。

互斥元是 C++ 中最常见的数据保护机制，但并非万能💊。精心组织代码来保护正确的数据（）以及避免接口中固有的竞争条件（）也是很重要的。互斥元自身也存在问题，比如 **死锁（deadlock）**（）和保护过多过少数据（）。接下来，让我们从基础开始。

### 使用 C++ 中的互斥元

在 C++ 中，通过构造 `std::mutex` 的实例来创建互斥元，调用成员函数 `lock()` 来锁定它，调用成员函数 `unlock()` 来解锁它。然而这种 `malloc() / free()` 和 `new / delete` 的调用方式使得你必须在函数的各种出口上都调用 `unlock()`，包括异常所导致的返回。就像之前 `join()` 的问题一样，C++ 社区偏向 RAII 惯用法来解决问题，好消息 C++ 标准库想到了。C++ 标准库提供了 `std::lock_guard` 类模板，实现了互斥元的 RAII 惯用法：在构造时锁定给定的互斥元，在析构时将互斥元接受，从而保证被锁定互斥元从始至终被正确解锁。

```cpp
#include <algorithm>
#include <list>
#include <mutex>

std::list<int> some_list;
std::mutex some_mutex;

void add_to_list(int new_value) {
  std::lock_guard<std::mutex> guard(some_mutex);
  some_list.push_back(new_value);
}

bool list_contains(int value_to_find) {
  std::lock_guard<std::mutex> guard(some_mutex);
  return std::find(std::begin(some_list), std::end(some_list), value_to_find) !=
         std::end(some_list);
}
```

在上述代码中，全局变量 `some_list` 被相应的 `std::mutex` 的全局实例 `some_mutex` 保护。在函数 `add_to_list()` 和 `list_contains` 中使用 `std::lock_guard<std::mutex>` 意味着对这两个函数的访问是互斥的，`list_contains()` 将无法在 `add_to_list()` 进行修改的过程中访问到该链表。

尽管这种全局变量的使用方式偶尔也是可以的，但大部分情况下的做法是，在类中将互斥元和要保护的数据组织在一起。这是标准的 OOP 的设计规则，通过将它们放在一起，清除地标记它们是相关的，还可以封装成函数以及强制保护。在这种设计模式下，函数被转换为类的方法，数据结构和互斥元成为 `private` 成员变量。如果类的所有成员函数在访问任意其他数据成员之前锁定互斥元，并在操作完成时解锁，这数据对所有访问者都被很好的保护了。

其实，并没有那么简单，你可以猜想，如果一个成员函数返回保护数据的指针或引用，那么所有成员函数都正确的锁定互斥元也是没有意义的。因为，能够访问（并可能修改）该指针或引用的代码可以无需锁定互斥元就访问收保护的数据。因此使用互斥元保护数据是需要仔细的设计接口，以确保在对任意收保护的数据进行访问之前，互斥元已被锁定，且不留后门。

### 为保护共享数据精心设计代码

如你所见，用互斥元保护数据并不只是在每个成员函数中添加一个 `std::lock_guard` 那么简单。一个迷路的指针或引用，所有的保护都将白费。从外部的观点看，只要保证共享数据的可见性为 `private`，所有的成员函数不通过返回值或者输出参数（位于参数列表的指针或引用，用于输出）返回共享数据的指针或引用，就可以了。但除了保证 caller 不能获得 callee 传出的指针或引用外，从内部的角度看，保证成员函数没有向程序员不能掌握的函数传入指针或引用也是很重要的。即不能向 callee 传入指针或引用。其中特别危险的是：被调用的函数是通过参数或其他方式在 Runtime 提供的。例如：

```cpp
class some_data {
private:
    int a;
    std::string b;
public:
    void do_something();
};

class data_wrapper {
private:
    some_data data;
    std::mutex m;
public:
    template<typename Function>
    void process_data(Function, func) {
        std::lock_guard<std::mutex> l(m);
        func(data); // 将被保护的数据传入用户提供的不可控的函数
    }
};

some_data* unprotected;

void malicious_function(some_data& protected_data) {
    unprotected = protected_data;
}

data_wrapper x;

void foo() {
    x.process_data(malicious_function);
    unprotected->do_something();
}
```

在上述代码中，虽然 `process_data` 中使用 `std::lock_guard` 保护共享数据，但对用户提供的函数 `func()` 的调用意味着 `foo()` 可以传入 `malicious_function()` 来绕过保护，并可以无需锁定互斥元即可调用 `do_something()`。

从根本上来说，这个代码的问题在于：没有真正的标记**所有的**访问共享数据的代码为**互斥的（mutually exclusive）**。这里的代码忽略了 `foo()` 中调用 `unprotected->do_something()` 的代码。

不幸的是，这个问题不是 C++ 标准库可以帮你解决的，只有身为程序员的你去锁定正确的互斥元来保护共享数据。一个准则是：

> 不要将受保护对象的指针和应用传递到锁的范围之外，无论是通过从函数中返回它们，还是将其存放在外部可见的内存中，还是作为参数传递给用户提供的函数。

虽然这是使用互斥元保护共享数据时经常犯的错误，但这绝非唯一可能的隐患。在下一节你会看到，即使当数据被互斥元好好保护的时候，仍可能存在竞争条件。
